<!DOCTYPE html>
<html lang="ru">
	<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">
	<meta name="description" content="IT простым языком">
	<meta name="generator" content="HUGO">

	<meta name="theme-color" content="#ffffff">

    
    <link rel="stylesheet" href="/sass/main.min.2410c89c79b6e042a424a6cef6ba5cbff430844ddffbec9f142931da8c515642.css" integrity="sha256-JBDInHm24EKkJKbO9rpcv/QwhE3f&#43;&#43;yfFCkx2oxRVkI=">
    <title> IT простым языком </title>
</head>

<body>
	<div id="top"/>
<header>
    <div align="center">
        +---------------------------+<br>
        |.-------------------------.|<br>
        ||&nbsp;<a href="/">kee_reel@blog</a>:~$ cd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||<br>
        ||&nbsp;<a href="/c">c</a>&nbsp;&nbsp;<a href="/cpp">c++</a>&nbsp;&nbsp;<a href="/python">python</a>&nbsp;&nbsp;<a href="/linux">linux</a>&nbsp;&nbsp;&nbsp;||<br>
        ||&nbsp;<a href="/opengl">opengl</a>&nbsp;&nbsp;<a href="/sql">sql</a>&nbsp;&nbsp;<a href="/network">networks</a>&nbsp;&nbsp;&nbsp;||<br>
        ||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||<br>
        ||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="/about">обо_мне</a>&nbsp;||<br>
        |.-------------------------.|<br>
        +-::---------------------::-+<br>
        .---------------------------.<br>
        &nbsp;//&nbsp;/o<a href="/links">o</a>oooooooooooooooooooo\\&nbsp;\\&nbsp;<br>
        &nbsp;//&nbsp;/oooooooooooooooooooooooo\\&nbsp;\\&nbsp;<br>
        //-------------------------------\\<br>
        \\-------------------------------//<br>
    </div>
    <hr>
</header>

		
	<div id="wrapper">
		<div class="container">
			<section id="main_content">
    
    
        <div style="display: flex; justify-content: space-between;">
            
                <a href="https://kee-reel.com/cpp/intro/">◀ Различия между C и C&#43;&#43;</a>
            
            
                <a href="https://kee-reel.com/cpp/operators/">Переопределение операторов ▶</a>
            
        </div>
        <hr>
    
    <h1>C&#43;&#43;. Классы</h1>
    
    
        <h3>Время чтения: 7 мин</h3>
    
    <p>Основной особенностью C++ являются классы &ndash; без них, C++ практичеси ничем бы не отличался от Си.</p>
<p>Прежде чем мы перейдём к использованию классов, я расскажу откуда классы взялись &ndash; про объектно-ориентированное программирование.</p>
<p>Объектно-ориентированное программирование (ООП) &ndash; подход к написанию программ при котором:</p>
<ul>
<li>Программа представляется в виде набора объектов и связей между ними</li>
<li>Все объекты являются экземплярами классов</li>
<li>Классы образуют иерархию наследования (про это в другой статье)</li>
</ul>
<p>Сейчас расскажу подробно что это всё значит.</p>
<h1 id="объект">Объект</h1>
<p>В реальном мире мы с тобой постоянно взаимодействуем с какими-то объектами: кружка, стул, стол, телефон и т.д.</p>
<p>Как это всё может относиться к программированию?</p>
<p>До сих пор, твои программы представляли собой набор функций, которые вызывают друг друга в определённой последовательности (или просто одна функция). Этот подход называется процедурным &ndash; он хорошо себя показывает если нужно написать программу, которая выполняет только одну задачу.</p>
<p>Однако, если твоя программа делает сразу много задач, то тебе удобнее будет использовать ООП. С помощью этого подхода, ты сможешь представить свою программу как набор объектов, каждый из которых будет ответствененн только за свою область задач.</p>
<p>Вот пример простой программы &ldquo;Список рецептов&rdquo;, в которой можно создавать, изменять и удалять рецепты:</p>
<p><img src="/assets/images/python-classes-reciples.png" alt="Программа &amp;ldquo;Список рецептов&amp;rdquo;"></p>
<p>Всё что я сделал &ndash; это разнёс функции программы по разным объектам.</p>
<p>Чтобы добавить ещё больше контекста &ndash; вот примеры задач, которые я мог бы решать как программист:</p>
<ul>
<li>Нужно чтобы теперь файл базы данных лежал в другой папке:
<ul>
<li>Залезу в код объекта &ldquo;База Данных&rdquo;:
<ul>
<li>Поменяю путь до файла</li>
</ul>
</li>
</ul>
</li>
<li>Нужно увеличить размер кнопок в интерфейсе на 50%:
<ul>
<li>Залезу в код объекта &ldquo;Пользовательский Интерфейс&rdquo;:
<ul>
<li>Поменяю свойство размера кнопок</li>
</ul>
</li>
</ul>
</li>
<li>Нужно добавить для рецепта новое численное поле &ldquo;Время приготовления&rdquo;:
<ul>
<li>Залезу в код объекта &ldquo;База Данных&rdquo;:
<ul>
<li>Добавлю поле cooking_duration</li>
</ul>
</li>
<li>Залезу в код объекта &ldquo;Пользовательский Интерфейс&rdquo;:
<ul>
<li>Добавлю новое численное поле ввода</li>
<li>Подпишу его &ldquo;Время приготовления&rdquo;</li>
<li>Добавлю дополнительный параметр cooking_duration, который отправляю в объект &ldquo;Список Рецептов&rdquo;</li>
</ul>
</li>
<li>Залезу в код объекта &ldquo;Список Рецептов&rdquo;:
<ul>
<li>Добавлю логику получения значения cooking_duration из данных от объекта &ldquo;Пользовательский Интерфейс&rdquo;</li>
<li>Изменю запросы на добавление/изменение/удаление в объект &ldquo;База Данных&rdquo;, чтобы они учитывали новое значение cooking_duration</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>В этом случае ООП не убавило работы &ndash; мне нужно писать столько же кода, чтобы выполнить задачу. Однако, теперь весь этот код сгруппирован в объектах, и мне намного легче удержать в голове взаимосвязи между тремя объектами, нежели множественные вызовы между десятками функций.</p>
<p>Это я в общих чертах описал чем отличается ООП от процедурного программирования, которым мы занимались до этого. Теперь рассмотрим классы.</p>
<h1 id="класс">Класс</h1>
<p>Раньше &ndash; данные и функции для их обработки у тебя были разделены, а теперь класс, для удобства, объединяет их в одном месте.</p>
<p><strong>Класс</strong> &ndash; это совокупность:</p>
<ul>
<li>Полей &ndash; переменных, определённых <strong>внутри</strong> класса</li>
<li>Методов &ndash; функций, определённых <strong>внутри</strong> класса и работающих с полями</li>
</ul>
<p><strong>Объект</strong> &ndash; это экземпляр класса. Иными словами, объект &ndash; это переменная, содержащая в себе все поля и методы, описанные в классе.</p>
<p>Разберём на аналогии с кружкой кофе.</p>
<p><img src="/assets/images/classes.png" alt="Класс Кофе"></p>
<p>То есть если мы описали какой-то класс, мы не можем его использовать по назначению &ndash; нельзя выпить описание кружки кофе, можно выпить только экземпляр кружки кофе.</p>
<p>Давай создадим класс &ldquo;Кофе&rdquo; и попробуем что-то с ним сделать.</p>
<p>Для начала подключим необходимый нам заголовочный файл:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Для вывода в консоль
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">// Для функций работы со строками
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span></code></pre></div><p>После этого опишем класс &ldquo;Кофе&rdquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Определяем новый класс с именем Coffee
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Coffee</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Про public мы поговорим в следующей статье, пока не обращай внимания
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Конструктор - метод, вызываемый при создании объекта
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Coffee(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>type, <span style="color:#66d9ef">int</span> temperature, <span style="color:#66d9ef">int</span> volume)
</span></span><span style="display:flex;"><span>	{ 
</span></span><span style="display:flex;"><span>		m_temperature <span style="color:#f92672">=</span> temperature;
</span></span><span style="display:flex;"><span>		m_volume <span style="color:#f92672">=</span> volume;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Выделяем память под строку
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		m_type <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[strlen(type)];
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Копируем type в m_type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		strcpy(m_type, type);
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Constructed &#34;</span> <span style="color:#f92672">&lt;&lt;</span> volume <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ml cup of &#34;</span> <span style="color:#f92672">&lt;&lt;</span>
</span></span><span style="display:flex;"><span>			(temperature <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">50</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;hot&#34;</span> <span style="color:#f92672">:</span> (temperature <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">30</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;warm&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;cold&#34;</span>)) <span style="color:#f92672">&lt;&lt;</span>
</span></span><span style="display:flex;"><span>			 <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> type <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; coffee. &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Деструктор - метод, вызываемый при удалении объекта
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#f92672">~</span>Coffee()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Освобождаем память под строку при удалении объекта
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Destructed &#34;</span> <span style="color:#f92672">&lt;&lt;</span> m_type <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">delete</span>[] m_type;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Метод drink()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Принимает на вход объём выпитого кофе и вычитает его из оставшегося объёма чашки
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">drink</span>(<span style="color:#66d9ef">int</span> ml_to_drink)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Проверка, чтобы последний глоток кофе не вычел больше, чем осталось
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		ml_to_drink <span style="color:#f92672">=</span> m_volume <span style="color:#f92672">&gt;</span> ml_to_drink <span style="color:#f92672">?</span> ml_to_drink : m_volume;
</span></span><span style="display:flex;"><span>		m_volume <span style="color:#f92672">-=</span> ml_to_drink;;
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Drank &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ml_to_drink <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ml of &#34;</span> <span style="color:#f92672">&lt;&lt;</span> m_type <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Поля класса - переменные, которые будут лежать внутри объекта
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>m_type; <span style="color:#75715e">// Тип кофе
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> m_temperature; <span style="color:#75715e">// Температура
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> m_volume; <span style="color:#75715e">// Объём
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}; <span style="color:#75715e">// ОБРАТИ ВНИМАНИЕ - в конце определения класса стоит &#34;;&#34;
</span></span></span></code></pre></div><blockquote>
<p>В C++ для работы со строками используют std::string, но я специально здесь сделал через Си-шные строки, чтобы показать удобство конструктора и деструктора.</p>
</blockquote>
<p>В этом фрагменте кода я сделал:</p>
<ul>
<li>Класс &ndash; задал название класса Coffee</li>
<li>Конструктор &ndash; особый метод, который вызывается при создании нового объекта</li>
<li>Деструктор &ndash; особый метод, который вызывается при удалении объекта</li>
<li>Обычный метод drink() &ndash; он будет вызываться у объекта, чтобы &ldquo;выпить&rdquo; его</li>
<li>Поля &ndash; m_type, m_temperature,  m_volume</li>
</ul>
<blockquote>
<p>Я дописал &ldquo;m_&rdquo; перед названиями полей (m &ndash; сокращение от Member, член класса), потому что это один из стилей их наименования. В этом случае всегда видно &ndash; обращаемся мы к полю класса или любой другой переменной. Рекомендую его придерживаться, но не настаиваю на этом.</p>
</blockquote>
<p>Ну и давай теперь создадим несколько объектов этого класса, и повызываем у них метод drink():</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Комментариями я указал что будет выведено в консоль
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	Coffee c1(<span style="color:#e6db74">&#34;espresso&#34;</span>, <span style="color:#ae81ff">90</span>, <span style="color:#ae81ff">50</span>); 
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Created 50ml cup of hot espresso coffee.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Coffee c2(<span style="color:#e6db74">&#34;americano&#34;</span>, <span style="color:#ae81ff">45</span>, <span style="color:#ae81ff">200</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Created 200ml cup of warm americano coffee.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Coffee <span style="color:#f92672">*</span>c3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Coffee(<span style="color:#e6db74">&#34;glasse&#34;</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">300</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Created 300ml cup of cold glasse coffee.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	c1.drink(<span style="color:#ae81ff">30</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Drank 30ml of espresso.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	c1.drink(<span style="color:#ae81ff">30</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Drank 20ml of espresso.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	c2.drink(<span style="color:#ae81ff">500</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Drank 200ml of americano.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	c2.drink(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Drank 0ml of americano.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	c3<span style="color:#f92672">-&gt;</span>drink(<span style="color:#ae81ff">25</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Drank 25ml of glasse.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Destructed ameriacano.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Destructed espresso.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Хочу обратить твоё внимание на два новых оператора: &ldquo;new&rdquo; и &ldquo;delete&rdquo;.</p>
<h3 id="new">new</h3>
<p>Для динамического выделения памяти под объект, я использовал оператор &ldquo;new&rdquo;.</p>
<blockquote>
<p>Да, &ldquo;new&rdquo; это унарный оператор, который пишется перед типом. В Си у нас был только унарный оператор отрицания &ldquo;!&rdquo;.</p>
</blockquote>
<p>В Си для выделения памяти мы пользовались функциями malloc() и calloc(), а в C++ вместо этого используют new &ndash; в чём разница?</p>
<p>malloc/calloc лишь выделял память &ndash; а теперь у нас появилась необходимость в вызове конструктора объекта.</p>
<p>new выполняет сразу две задачи:</p>
<ul>
<li>Выделение необходимого объёма памяти под объект</li>
<li>Вызов конструктора, описанного в классе</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Coffee <span style="color:#f92672">*</span>c3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Coffee(<span style="color:#e6db74">&#34;glasse&#34;</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">300</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// То же самое что и
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>c3 <span style="color:#f92672">=</span> (Coffee<span style="color:#f92672">*</span>) malloc(<span style="color:#66d9ef">sizeof</span>(Coffee)); <span style="color:#75715e">// Выделение памяти
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">*</span>c3 <span style="color:#f92672">=</span> Coffee(<span style="color:#e6db74">&#34;glasse&#34;</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">300</span>); <span style="color:#75715e">// Вызов конструктора для выделенной памяти
</span></span></span></code></pre></div><h3 id="delete">delete</h3>
<p>И ещё одно &ndash; смотри, деструктор для &ldquo;glasse&rdquo; не вызвался. Это произошло из-за того, что он у нас хранится в указателе, который мы забыли подчистить.</p>
<p>Если же его подчистить, то всё встанет на свои места:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">delete</span> c3;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Destructed glasse.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Destructed ameriacano.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Destructed espresso.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>В Си для освобождения памяти мы использовали free(), а тут какой-то delete &ndash; в чём разница?</p>
<p>delete &ndash; это ещё один оператор, который используется для вызова деструктора объекта и освобождения памяти.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">delete</span> c3;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// То же самое что и
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>c3<span style="color:#f92672">-&gt;~</span>Coffee(); <span style="color:#75715e">// Вызов деструктора для выделенной памяти
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>free(c3); <span style="color:#75715e">// Освобождение памяти
</span></span></span></code></pre></div><blockquote>
<p>Если использовать только free, то деструктор не вызовется.</p>
</blockquote>
<h1 id="header-1заключение"><a href="#header-1"></a>Заключение</h1>
<p>Итого, мы изучили:</p>
<ul>
<li>Объектно-ориентированное программирование &ndash; описание программы как набор объектов</li>
<li>Класс &ndash; совокупность полей и методов, работающих с ними</li>
<li>Объект &ndash; экземпляр класса</li>
<li>Поле &ndash; переменная внутри класса</li>
<li>Метод &ndash; функция внутри класса
<ul>
<li>Конструктор &ndash; особый метод, вызывающийся при создании объекта</li>
<li>Деструктор &ndash; особый метод, вызывающийся при удалении объекта</li>
</ul>
</li>
<li>Операторы
<ul>
<li>new &ndash; динамическое создание объекта (malloc + конструктор)</li>
<li>delete &ndash; удаление динамически созданного объекта (деструктор + free)</li>
</ul>
</li>
</ul>
<p>Если что &ndash; пиши, я помогу и постараюсь объяснить лучше.</p>
<p>То, что мы с тобой сейчас изучили, тебе должно хватить для решения простых задач. Однако, это лишь вершина айсберга:</p>
<p><img src="/assets/images/iceberg.png" alt="C++ айсберг"></p>
<p>Не пугайся, мы не будем сразу разбирать весь &ldquo;айсберг&rdquo; &ndash; мы будем откалывать от него только самые полезные куски, и рассматривать их со всех сторон, пока полностью не разберёмся.</p>
<p>В следующей статье мы рассмотрим удобный способ вызова методов &ndash; переопределение операторов.</p>

    <hr>
    <div align="center">
        <a href="https://kee-reel.com/cpp/classes/#top">▲ В начало ▲</a>
    </div>
    
        <hr>
        <div style="display: flex; justify-content: space-between;">
            
                <a href="https://kee-reel.com/cpp/intro/">◀ Различия между C и C&#43;&#43;</a>
            
            
                <a href="https://kee-reel.com/cpp/operators/">Переопределение операторов ▶</a>
            
        </div>
    

			</section>
		</div>
	</div>

    <footer>
    <hr>
    <div align="center">
        Home server: Raspberry Pi 4<br>
        Temperature: 53<br>
Uptime: 1 hour, 7 minutes
    </div>
</footer>

</body>
</html>
